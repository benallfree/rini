
export default "(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\n  var __commonJS = (callback, module) => () => {\n    if (!module) {\n      module = {exports: {}};\n      callback(module.exports, module);\n    }\n    return module.exports;\n  };\n  var __exportStar = (target, module, desc) => {\n    if (module && typeof module === \"object\" || typeof module === \"function\") {\n      for (let key of __getOwnPropNames(module))\n        if (!__hasOwnProp.call(target, key) && key !== \"default\")\n          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});\n    }\n    return target;\n  };\n  var __toModule = (module) => {\n    if (module && module.__esModule)\n      return module;\n    return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", {value: module, enumerable: true})), module);\n  };\n\n  // node_modules/isomorphic-ws/browser.js\n  var require_browser = __commonJS((exports, module) => {\n    var ws = null;\n    if (typeof WebSocket !== \"undefined\") {\n      ws = WebSocket;\n    } else if (typeof MozWebSocket !== \"undefined\") {\n      ws = MozWebSocket;\n    } else if (typeof global !== \"undefined\") {\n      ws = global.WebSocket || global.MozWebSocket;\n    } else if (typeof window !== \"undefined\") {\n      ws = window.WebSocket || window.MozWebSocket;\n    } else if (typeof self !== \"undefined\") {\n      ws = self.WebSocket || self.MozWebSocket;\n    }\n    module.exports = ws;\n  });\n\n  // src/client/createClientNetcode.ts\n  var WebSocket2 = __toModule(require_browser());\n\n  // node_modules/nanoevents/index.js\n  var createNanoEvents = () => ({\n    events: {},\n    emit(event, ...args) {\n      ;\n      (this.events[event] || []).forEach((i) => i(...args));\n    },\n    on(event, cb) {\n      ;\n      (this.events[event] = this.events[event] || []).push(cb);\n      return () => this.events[event] = (this.events[event] || []).filter((i) => i !== cb);\n    }\n  });\n\n  // src/callem/index.ts\n  function callem() {\n    const emitter = createNanoEvents();\n    return [\n      (callback) => {\n        const unsub = emitter.on(\"callem\", callback);\n        return unsub;\n      },\n      (data) => {\n        emitter.emit(\"callem\", data);\n      }\n    ];\n  }\n\n  // src/n53/transport.ts\n  var createTransportPacker = (config) => {\n    let messageId = 0;\n    const pack = (type, message, refId = 0) => {\n      const wrapper = {\n        id: messageId++,\n        refId,\n        type,\n        message\n      };\n      const packed = JSON.stringify(wrapper);\n      return [packed, wrapper];\n    };\n    const unpack = (packed) => {\n      const wrapper = (() => {\n        try {\n          const data = JSON.parse(packed);\n          if (!(\"id\" in data)) {\n            throw new Error(`Invalid parsed packet format ${JSON.stringify(data)} (${packed})`);\n          }\n          return data;\n        } catch (e) {\n          throw new Error(`Parse failed for ${packed}, ${e}`);\n        }\n      })();\n      return wrapper;\n    };\n    return {\n      pack,\n      unpack\n    };\n  };\n\n  // src/n53/index.ts\n  var createNetcode = () => {\n    const transport = createTransportPacker();\n    return transport;\n  };\n\n  // src/common/index.ts\n  var MessageTypes;\n  (function(MessageTypes2) {\n    MessageTypes2[MessageTypes2[\"Login\"] = 1] = \"Login\";\n    MessageTypes2[MessageTypes2[\"Session\"] = 2] = \"Session\";\n    MessageTypes2[MessageTypes2[\"NearbyEntities\"] = 3] = \"NearbyEntities\";\n    MessageTypes2[MessageTypes2[\"PositionUpdate\"] = 4] = \"PositionUpdate\";\n  })(MessageTypes || (MessageTypes = {}));\n  var netcode = createNetcode();\n\n  // src/client/createClientNetcode.ts\n  var createClientNetcode = (settings) => {\n    let retryCount = 0;\n    let isConnected = false;\n    const _settings = {\n      idToken: \"\",\n      host: \"192.168.1.2\",\n      port: 3e3,\n      maxRetries: 0,\n      retryDelayMs: 5e3,\n      awaitReplyTimeoutMs: 1e3,\n      ...settings,\n      logger: {\n        info: console.log,\n        warn: console.warn,\n        error: console.error,\n        debug: console.log,\n        ...settings?.logger\n      }\n    };\n    const {\n      idToken,\n      host,\n      port,\n      maxRetries,\n      retryDelayMs,\n      awaitReplyTimeoutMs,\n      logger\n    } = _settings;\n    const [onMessage, emitMessage] = callem();\n    const [onConnect, emitConnect] = callem();\n    const [onDisconnect, emitDisconnect] = callem();\n    let conn;\n    const connect = () => {\n      retryTid = void 0;\n      const Ws = WebSocket2.default || WebSocket2;\n      console.log({Ws});\n      conn = new Ws(`ws://${host}:${port}`);\n      conn.onmessage = (e) => {\n        const {data} = e;\n        if (typeof data !== \"string\") {\n          throw new Error(`Unsupported data type ${data}`);\n        }\n        const msg = netcode.unpack(data);\n        emitMessage(msg);\n      };\n      conn.onopen = () => {\n        retryCount = 0;\n        logger.debug(\"connected\");\n        logger.debug(\"listening for data\");\n        if (idToken) {\n          login({idToken}).then(() => {\n            isConnected = true;\n            emitConnect({\n              attempt: retryCount\n            });\n          }).catch((e) => {\n            logger.error(`Error logging in`, e);\n            cleanup();\n            reconnect();\n          });\n        }\n      };\n      conn.onclose = () => {\n        logger.debug(\"close\");\n        cleanup();\n        reconnect();\n      };\n      conn.onerror = (e) => {\n        logger.error(e);\n        cleanup();\n        reconnect();\n      };\n      const cleanup = () => {\n        logger.debug(\"Cleaning up\");\n        conn.close();\n        isConnected = false;\n        emitDisconnect({\n          attempt: retryCount\n        });\n      };\n    };\n    let retryTid;\n    const reconnect = () => {\n      if (retryTid)\n        return;\n      logger.debug(\"scheduling reconnect\");\n      if (maxRetries && retryCount >= maxRetries) {\n        logger.debug(`Max retries exceeded`);\n        return;\n      }\n      retryCount++;\n      retryTid = setTimeout(() => {\n        logger.debug(\"attempting reconnect now\");\n        connect();\n      }, retryDelayMs);\n    };\n    connect();\n    const sendMessageAndAwaitReply = async (type, msg) => {\n      const [packed, certified] = netcode.pack(type, msg);\n      logger.debug({certified});\n      return new Promise((resolve, reject) => {\n        const tid = setTimeout(() => {\n          unsub();\n          reject(`Timed out awaiting reply to ${certified.id}`);\n        }, awaitReplyTimeoutMs);\n        const unsub = onMessage((m) => {\n          if (m.refId !== certified.id)\n            return;\n          unsub();\n          clearTimeout(tid);\n          resolve(m);\n        });\n        send(packed).catch((e) => {\n          unsub();\n          clearTimeout(tid);\n          reject(`Error sending. Trigger reconnect`);\n        });\n      });\n    };\n    const sendMessage = (type, msg) => {\n      const [packed] = netcode.pack(type, msg);\n      send(packed).catch((e) => {\n        logger.error(`Error sending message`, e);\n      });\n    };\n    const login = (message) => sendMessageAndAwaitReply(MessageTypes.Login, message);\n    const updatePosition = async (message) => {\n      sendMessage(MessageTypes.PositionUpdate, message);\n    };\n    const send = async (data) => conn.send(data);\n    const [onNearbyEntities, emitNearbyEntities] = callem();\n    const dispatchHandlers = {\n      [MessageTypes.NearbyEntities]: emitNearbyEntities\n    };\n    onMessage((m) => {\n      const dispatchHandler = dispatchHandlers[m.type];\n      if (!dispatchHandler)\n        return;\n      dispatchHandler(m.message);\n    });\n    const api = {\n      close: () => conn.close(),\n      login,\n      updatePosition,\n      onConnect,\n      onDisconnect,\n      isConnected: () => isConnected,\n      onNearbyEntities\n    };\n    return api;\n  };\n\n  // src/app/worker.ts\n  var {log} = window;\n  var heartbeat = () => {\n    window.send({type: \"heartbeat\"});\n    setTimeout(heartbeat, 500);\n  };\n  heartbeat();\n  window.onMessage((msg) => {\n    const _msg = msg;\n    const dispatch = {};\n    const _d = dispatch[_msg.type];\n    if (!_d) {\n      throw new Error(`Message type ${_msg.type} is not implemented`);\n    }\n    _d(_msg);\n    log(\"Rx main->worker\", {_msg});\n  });\n  var client = createClientNetcode({\n    logger: {\n      info: log,\n      debug: log,\n      error: log,\n      warn: log\n    }\n  });\n  window.ready();\n})();\n";

